/*
 * command chaining &&
 * */

#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))

#include "../include/chaining.h"
#include "../include/parsing_utils.h"

/*
 * mkdir testdir && cd testdir && touch datei.txt
 * ping -c 1 google.com && echo "Netzwerk OK"
 * uname -a && cat /etc/os-release && free -h && df -h && uptime
 uname -a && cat /etc/os-release && free -รถ && df -h && uptime
 *
 * chainig with && (AND) only execute the next if the previous one succeeded
 * this means we have to always check for the return of the previous command
 * to "approve" the next one
 *
 * */



 char **split_on_chain(char *input) {
     // NOTE: This was mostly AI generated by GPT 4.1 in ZED IDE

     // First, count how many commands there are (number of "&&" + 1)
     int count = 1;
     char *ptr = input;
     while ((ptr = strstr(ptr, "&&")) != NULL) {
         count++;
         ptr += 2; // move past "&&"
     }

     // Allocate output array (+1 for NULL terminator)
     char **output = malloc(sizeof(char*) * (count + 1));
     if (!output) return NULL;

     int idx = 0;
     char *start = input;
     while (1) {
         char *end = strstr(start, "&&");
         if (end) {
             size_t len = end - start;
             // Skip leading spaces
             while (len > 0 && (*start == ' ' || *start == '\t')) {
                 start++;
                 len--;
             }
             // Trim trailing spaces
             while (len > 0 && (start[len-1] == ' ' || start[len-1] == '\t')) {
                 len--;
             }
             output[idx] = malloc(len + 1);
             if (output[idx]) {
                 strncpy(output[idx], start, len);
                 output[idx][len] = '\0';
             }
             idx++;
             start = end + 2; // skip "&&"
         } else {
             // Last command
             size_t len = strlen(start);
             // Skip leading spaces
             while (len > 0 && (*start == ' ' || *start == '\t')) {
                 start++;
                 len--;
             }
             // Trim trailing spaces
             while (len > 0 && (start[len-1] == ' ' || start[len-1] == '\t')) {
                 len--;
             }
             output[idx] = malloc(len + 1);
             if (output[idx]) {
                 strncpy(output[idx], start, len);
                 output[idx][len] = '\0';
             }
             idx++;
             break;
         }
     }
     output[idx] = NULL; // null-terminate the array
     return output;
 }
